{% extends 'tailadmin/layouts/base.html.twig' %}

{% block content %}
<div class="flex flex-col h-[calc(100vh-80px)] max-h-screen overflow-hidden">
    <!-- Compact Header - Sticky -->
    <div class="sticky top-0 z-10 bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-800 shadow-sm">
        <div class="px-4 py-3 md:px-6">
            <div class="flex items-center justify-between gap-3 flex-wrap">
                <!-- Left: Title & Badges -->
                <div class="flex-1 min-w-0">
                    <div class="flex items-center gap-2 flex-wrap mb-2">
                        <a href="{{ path('admin_requests_list') }}" class="inline-flex items-center text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors" title="Retour">
                            <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                            </svg>
                        </a>
                        <h1 class="text-lg md:text-xl font-semibold text-gray-900 dark:text-white truncate">
                            {{ request.title }}
                        </h1>
                    </div>
                    <div class="flex items-center gap-2 flex-wrap">
                        <span class="inline-flex items-center rounded-full bg-brand-50 dark:bg-brand-500/15 px-2 py-0.5 text-xs font-medium text-brand-600 dark:text-brand-400">
                            {{ request.type|upper }}
                        </span>
                        {% if request.priority == 'high' %}
                        <span class="inline-flex items-center rounded-full bg-error-100 dark:bg-error-900/30 px-2 py-0.5 text-xs font-medium text-error-600 dark:text-error-400">
                            Haute
                        </span>
                        {% elseif request.priority == 'medium' %}
                        <span class="inline-flex items-center rounded-full bg-warning-100 dark:bg-warning-900/30 px-2 py-0.5 text-xs font-medium text-warning-600 dark:text-warning-400">
                            Moyenne
                        </span>
                        {% else %}
                        <span class="inline-flex items-center rounded-full bg-gray-100 dark:bg-gray-800 px-2 py-0.5 text-xs font-medium text-gray-600 dark:text-gray-400">
                            Basse
                        </span>
                        {% endif %}
                        {% if request.status == 'resolved' %}
                        <span class="inline-flex items-center rounded-full bg-success-100 dark:bg-success-900/30 px-2 py-0.5 text-xs font-medium text-success-600 dark:text-success-400">
                            Résolue
                        </span>
                        {% elseif request.status == 'in_progress' %}
                        <span class="inline-flex items-center rounded-full bg-brand-100 dark:bg-brand-900/30 px-2 py-0.5 text-xs font-medium text-brand-600 dark:text-brand-400">
                            En cours
                        </span>
                        {% else %}
                        <span class="inline-flex items-center rounded-full bg-gray-100 dark:bg-gray-800 px-2 py-0.5 text-xs font-medium text-gray-600 dark:text-gray-400">
                            En attente
                        </span>
                        {% endif %}
                        <span class="text-xs text-gray-500 dark:text-gray-400 hidden sm:inline">
                            {{ request.creatorName }} → {{ request.recipientName }}
                        </span>
                    </div>
                </div>
                
                <!-- Right: Quick Info (Desktop) -->
                <div class="hidden lg:flex items-center gap-4 text-xs text-gray-500 dark:text-gray-400">
                    <div class="flex items-center gap-1">
                        <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                        </svg>
                        <span>{{ request.creatorName }}</span>
                    </div>
                </div>
            </div>
            
            <!-- Description (Always visible) -->
            {% if request.description %}
            <div class="mt-2 px-2 py-1.5 bg-gray-50 dark:bg-gray-800 rounded text-xs text-gray-600 dark:text-gray-400 line-clamp-2">
                {{ request.description }}
            </div>
            {% endif %}
        </div>
    </div>

    <!-- Chat Container - Flex Grow -->
    <div class="flex-1 flex flex-col min-h-0 bg-white dark:bg-gray-900" id="chat-container">
        <!-- Chat Header -->
        <div class="border-b border-gray-200 dark:border-gray-800 px-4 py-3 bg-gray-50 dark:bg-gray-800/50 flex-shrink-0">
            <div class="flex items-center gap-3">
                {% if otherUser %}
                <div class="flex h-9 w-9 items-center justify-center rounded-full bg-gradient-to-br from-brand-500 to-brand-600 text-white text-sm font-semibold shadow-sm">
                    {{ otherUser.firstName|first|upper }}{{ otherUser.lastName|first|upper }}
                </div>
                <div class="flex-1 min-w-0">
                    <h3 class="font-semibold text-sm text-gray-900 dark:text-white truncate">
                        {{ otherUser.firstName }} {{ otherUser.lastName }}
                    </h3>
                    <p class="text-xs text-gray-500 dark:text-gray-400 truncate">
                        {% if otherUser.userType %}{{ otherUser.userType|capitalize }} • {% endif %}{{ otherUser.email }}
                    </p>
                </div>
                {% else %}
                <div>
                    <h3 class="font-semibold text-sm text-gray-900 dark:text-white">Messages</h3>
                </div>
                {% endif %}
            </div>
        </div>

        <!-- Messages Area - Scrollable -->
        <div 
            class="flex-1 flex flex-col min-h-0 overflow-hidden"
            x-data="requestChatManager({{ requestId }})"
            x-init="init()"
        >
            <!-- Message Input - Fixed Top -->
            <div class="flex-shrink-0 border-b border-gray-200 dark:border-gray-800 bg-white dark:bg-gray-900 shadow-lg">
                <form @submit.prevent="sendMessage()" class="p-4 space-y-2">
                    <!-- Boutons d'upload - Ligne séparée sur mobile -->
                    <div class="flex flex-wrap gap-2 justify-center sm:justify-start">
                        <!-- Bouton Assistance IA -->
                        <button
                            type="button"
                            @click="toggleAIAssist()"
                            :class="aiAssistMode ? 'bg-brand-500 text-white' : 'border border-gray-300 bg-white text-gray-600 hover:bg-gray-50 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700'"
                            class="rounded-lg p-2 transition-colors flex-shrink-0 hover:scale-105 active:scale-95"
                            title="Assistance IA"
                        >
                            <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                            </svg>
                        </button>
                        <!-- Upload Image -->
                        <label class="cursor-pointer rounded-lg border border-gray-300 bg-white p-2 hover:bg-gray-50 dark:border-gray-700 dark:bg-gray-800 dark:hover:bg-gray-700 flex-shrink-0 transition-colors" title="Envoyer une image">
                            <input
                                type="file"
                                accept="image/*"
                                @change="handleImageUpload($event)"
                                class="hidden"
                            />
                            <svg class="h-5 w-5 text-gray-600 dark:text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                            </svg>
                        </label>
                        <!-- Prendre une photo -->
                        <label class="cursor-pointer rounded-lg border border-gray-300 bg-white p-2 hover:bg-gray-50 dark:border-gray-700 dark:bg-gray-800 dark:hover:bg-gray-700 flex-shrink-0" title="Prendre une photo">
                            <input
                                type="file"
                                accept="image/*"
                                capture="environment"
                                @change="handleCameraCapture($event)"
                                class="hidden"
                            />
                            <svg class="h-5 w-5 text-gray-600 dark:text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A 2 0 0 1 10.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                        </label>
                        <!-- Upload Audio -->
                        <label class="cursor-pointer rounded-lg border border-gray-300 bg-white p-2 hover:bg-gray-50 dark:border-gray-700 dark:bg-gray-800 dark:hover:bg-gray-700 flex-shrink-0" title="Envoyer un fichier audio">
                            <input
                                type="file"
                                accept="audio/*"
                                @change="handleAudioUpload($event)"
                                class="hidden"
                            />
                            <svg class="h-5 w-5 text-gray-600 dark:text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />
                            </svg>
                        </label>
                        <!-- Enregistrer Audio -->
                        <button
                            type="button"
                            @click="toggleAudioRecording()"
                            :class="isRecording ? 'bg-error-500 text-white hover:bg-error-600' : 'border border-gray-300 bg-white text-gray-600 hover:bg-gray-50 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700'"
                            class="rounded-lg p-2 transition-colors flex-shrink-0 hover:scale-105 active:scale-95"
                            :title="isRecording ? 'Arrêter l\'enregistrement' : 'Enregistrer un audio'"
                        >
                            <svg x-show="!isRecording" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                            </svg>
                            <svg x-show="isRecording" class="h-5 w-5 animate-pulse" fill="currentColor" viewBox="0 0 24 24">
                                <circle cx="12" cy="12" r="10" />
                            </svg>
                        </button>
                    </div>
                    <!-- Input et bouton Envoyer -->
                    <div class="flex gap-2 items-end">
                        <textarea
                            x-model="messageContent"
                            :placeholder="aiAssistMode ? 'Posez votre question à l\'IA... (Appuyez sur Entrée pour envoyer à l\'IA)' : 'Tapez votre message...'"
                            rows="1"
                            @input="$event.target.style.height = 'auto'; $event.target.style.height = $event.target.scrollHeight + 'px';"
                            class="flex-1 min-w-0 rounded-lg border px-4 py-2.5 text-sm resize-none focus:outline-none focus:ring-2 dark:bg-gray-800 dark:text-white max-h-32 overflow-y-auto"
                            :class="aiAssistMode ? 'border-blue-300 bg-blue-50 focus:border-blue-500 focus:ring-blue-500 dark:border-blue-700 dark:bg-blue-900/20' : 'border-gray-300 bg-white focus:border-brand-500 focus:ring-brand-500 dark:border-gray-700'"
                            style="min-height: 42px;"
                        ></textarea>
                        <button
                            type="submit"
                            :disabled="sending || uploading || !messageContent.trim() || (aiAssistMode && aiGenerating)"
                            class="rounded-lg px-4 py-2.5 text-sm font-medium text-white bg-brand-500 hover:bg-brand-600 focus:ring-brand-500 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed flex-shrink-0 transition-all shadow-sm hover:shadow-md flex items-center justify-center"
                            style="min-height: 42px;"
                        >
                            <svg x-show="!sending && !uploading && !aiGenerating" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                            </svg>
                            <span x-show="sending || uploading || aiGenerating" class="inline-flex items-center">
                                <svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                            </span>
                        </button>
                    </div>
                </form>
            </div>

            <!-- Zone d'Assistance IA -->
            <div 
                x-show="aiAssistMode" 
                class="flex-shrink-0 border-b border-blue-200 bg-blue-50 dark:bg-blue-900/20 p-3 dark:border-blue-800 shadow-lg"
                x-transition
            >
                <div class="flex items-start gap-3">
                    <svg class="h-5 w-5 text-blue-600 dark:text-blue-400 flex-shrink-0 mt-0.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <div class="flex-1">
                        <p class="text-sm font-medium text-blue-800 dark:text-blue-200 mb-1">
                            Mode Assistance IA activé
                        </p>
                        <p class="text-xs text-blue-700 dark:text-blue-300 mb-2">
                            Votre message sera envoyé à l'IA pour génération de réponse. Sélectionnez des messages ci-dessous pour donner le contexte.
                        </p>
                        <div class="flex items-center justify-between">
                            <div class="text-xs text-blue-600 dark:text-blue-400">
                                <span x-show="selectedMessageIds.length === 0" class="text-blue-500">Aucun message sélectionné</span>
                                <span x-show="selectedMessageIds.length > 0" class="font-medium">
                                    <span x-text="selectedMessageIds.length"></span> message(s) sélectionné(s) pour le contexte
                                </span>
                            </div>
                            <button
                                type="button"
                                @click="toggleAIAssist()"
                                class="text-xs text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-200 font-medium"
                            >
                                Désactiver
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Messages List - Scrollable -->
            <div
                id="messages-container"
                class="flex-1 overflow-y-auto overscroll-contain p-4 md:p-6 space-y-4"
                style="scroll-behavior: smooth; min-height: 0;"
            >
                {% for message in messages|reverse %}
                    <div class="flex {% if message.isFromMe %}justify-end{% else %}justify-start{% endif %} gap-2" data-message-id="{{ message.id }}" data-message-type="{{ message.type|default('text') }}">
                        <!-- Checkbox pour sélection -->
                        <div class="flex items-start pt-6" x-show="aiAssistMode">
                            <input
                                type="checkbox"
                                value="{{ message.id }}"
                                x-model="selectedMessageIds"
                                class="h-4 w-4 rounded border-gray-300 text-brand-500 focus:ring-brand-500 dark:border-gray-700"
                            />
                        </div>
                        <div class="flex max-w-[70%] flex-col {% if message.isFromMe %}items-end{% else %}items-start{% endif %}">
                            <span class="mb-1 text-xs text-gray-500 dark:text-gray-400">
                                {{ message.sender.firstName }} {{ message.sender.lastName }}
                                {% if message.sender.userType %}
                                    <span class="text-gray-400">({{ message.sender.userType|capitalize }})</span>
                                {% endif %}
                            </span>
                            <div
                                class="rounded-lg px-4 py-2 {% if message.isFromMe %}bg-brand-600{% else %}bg-gray-100 dark:bg-gray-700{% endif %}"
                            >
                                {% if message.type|default('') == 'image' and message.filePath %}
                                    <img 
                                        src="{{ message.filePath }}" 
                                        alt="Image" 
                                        class="max-w-full h-auto rounded cursor-pointer hover:opacity-90 transition-opacity"
                                        @click="openImageModal('{{ message.filePath }}')"
                                        style="max-height: 300px;"
                                    />
                                    {% if message.content %}
                                        <p class="text-sm mt-2 {% if message.isFromMe %}text-black{% else %}!text-gray-950 dark:!text-gray-100{% endif %}">{{ message.content }}</p>
                                    {% endif %}
                                {% elseif message.type|default('') == 'audio' %}
                                    {% if message.filePath %}
                                        <div class="flex items-center gap-2">
                                            <audio 
                                                controls 
                                                class="w-full max-w-xs" 
                                                style="min-width: 250px; height: 40px;"
                                                preload="metadata"
                                                data-audio-id="{{ message.id }}"
                                                onloadedmetadata="if (this.duration && !isNaN(this.duration) && this.duration > 0) { this.style.display = 'block'; }"
                                                oncanplay="if (this.duration && !isNaN(this.duration) && this.duration > 0) { this.style.display = 'block'; }"
                                            >
                                                <source src="{{ message.filePath }}" type="audio/webm">
                                                <source src="{{ message.filePath }}" type="audio/mpeg">
                                                <source src="{{ message.filePath }}" type="audio/wav">
                                                <source src="{{ message.filePath }}" type="audio/ogg">
                                                <source src="{{ message.filePath }}" type="audio/mp3">
                                                Votre navigateur ne supporte pas l'élément audio.
                                            </audio>
                                        </div>
                                    {% else %}
                                        <p class="text-sm text-red-500">⚠️ Fichier audio non disponible</p>
                                    {% endif %}
                                    {% if message.content %}
                                        <p class="text-sm mt-2 {% if message.isFromMe %}text-black{% else %}!text-gray-950 dark:!text-gray-100{% endif %}">{{ message.content }}</p>
                                    {% endif %}
                                {% else %}
                                    <p class="text-sm whitespace-pre-wrap {% if message.isFromMe %}text-black{% else %}!text-gray-950 dark:!text-gray-100{% endif %}">
                                        {% if message.content is defined and message.content is not null and message.content is not empty %}
                                            {{ message.content }}
                                        {% else %}
                                            <span class="italic opacity-75 {% if message.isFromMe %}text-black{% else %}text-gray-600 dark:text-gray-400{% endif %}">(Message vide)</span>
                                        {% endif %}
                                    </p>
                                {% endif %}
                            </div>
                            <span class="mt-1 text-xs text-gray-500 dark:text-gray-400">
                                {% if message.createdAt %}
                                    {{ message.createdAt|date('d/m/Y H:i') }}
                                {% endif %}
                            </span>
                        </div>
                    </div>
                {% else %}
                    <div class="flex items-center justify-center h-full">
                        <p class="text-gray-500 dark:text-gray-400">Aucun message pour le moment</p>
                    </div>
                {% endfor %}
            </div>
            
            <!-- Modal pour agrandir les images -->
            <div
                x-show="imageModalOpen"
                @click.away="closeImageModal()"
                @keydown.escape.window="closeImageModal()"
                class="fixed inset-0 z-50 flex items-center justify-center bg-black/75 backdrop-blur-sm"
                style="display: none;"
                x-cloak
            >
                <div class="relative max-w-7xl max-h-[90vh] p-4">
                    <button
                        @click="closeImageModal()"
                        class="absolute top-4 right-4 rounded-full bg-white/90 p-2 text-gray-800 hover:bg-white transition-colors"
                    >
                        <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                    <img 
                        :src="imageModalSrc" 
                        alt="Image agrandie" 
                        class="max-w-full max-h-[90vh] rounded-lg shadow-2xl cursor-pointer"
                        @click="closeImageModal()"
                    />
                </div>
            </div>
            
            <!-- Modal pour prévisualiser l'audio enregistré -->
            <div
                x-show="recordedAudioUrl"
                @click.away="cancelRecordedAudio()"
                @keydown.escape.window="cancelRecordedAudio()"
                class="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm"
                style="display: none;"
                x-cloak
            >
                <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl p-6 max-w-md w-full mx-4">
                    <h3 class="text-lg font-semibold text-gray-800 dark:text-white mb-4">Prévisualiser l'enregistrement</h3>
                    <div class="mb-4">
                        <p class="text-sm text-gray-600 dark:text-gray-400 mb-2">
                            Durée: <span x-text="formatTime(recordingTime)"></span>
                        </p>
                        <audio :src="recordedAudioUrl" controls class="w-full"></audio>
                    </div>
                    <div class="flex gap-3">
                        <button
                            @click="cancelRecordedAudio()"
                            class="flex-1 rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-300"
                        >
                            Annuler
                        </button>
                        <button
                            @click="sendRecordedAudio()"
                            :disabled="uploading"
                            class="flex-1 rounded-lg bg-brand-500 px-4 py-2 text-sm font-medium text-white hover:bg-brand-600 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            <span x-show="!uploading">Envoyer</span>
                            <span x-show="uploading">Envoi...</span>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- RightSheet pour la réponse de l'IA -->
            <div
                x-show="aiResponseSheetOpen"
                @click="aiResponseSheetOpen = false"
                x-transition:enter="transition-opacity ease-out duration-300"
                x-transition:enter-start="opacity-0"
                x-transition:enter-end="opacity-100"
                x-transition:leave="transition-opacity ease-in duration-200"
                x-transition:leave-start="opacity-100"
                x-transition:leave-end="opacity-0"
                class="fixed inset-0 z-50 bg-black/50 backdrop-blur-sm"
                style="display: none;"
                x-cloak
            ></div>

            <div
                x-show="aiResponseSheetOpen"
                @click.away="aiResponseSheetOpen = false"
                x-transition:enter="transition-transform ease-out duration-300"
                x-transition:enter-start="translate-x-full"
                x-transition:enter-end="translate-x-0"
                x-transition:leave="transition-transform ease-in duration-200"
                x-transition:leave-start="translate-x-0"
                x-transition:leave-end="translate-x-full"
                class="fixed right-0 top-0 z-50 h-full w-full max-w-md bg-white shadow-2xl dark:bg-gray-900"
                style="display: none;"
                x-cloak
            >
                <div class="flex h-full flex-col">
                    <!-- Header -->
                    <div class="sticky top-0 z-10 border-b border-gray-200 bg-white px-6 py-4 dark:border-gray-800 dark:bg-gray-900">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-semibold text-gray-800 dark:text-white/90">
                                Réponse de l'IA
                            </h3>
                            <button
                                @click="aiResponseSheetOpen = false"
                                class="rounded-lg p-2 text-gray-400 transition-colors hover:bg-gray-100 hover:text-gray-600 dark:hover:bg-gray-800 dark:hover:text-gray-300"
                            >
                                <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>
                    </div>

                    <!-- Content -->
                    <div class="flex-1 overflow-y-auto p-6">
                        <div class="mb-4 flex items-center gap-2">
                            <svg class="h-5 w-5 text-brand-600 dark:text-brand-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                            </svg>
                            <span class="text-sm font-medium text-brand-700 dark:text-brand-300">Réponse générée</span>
                        </div>
                        <div class="rounded-lg border border-brand-200 bg-brand-50 p-4 dark:border-brand-800 dark:bg-brand-900/20">
                            <p class="text-sm text-gray-700 dark:text-gray-300 whitespace-pre-wrap" x-text="aiResponse"></p>
                        </div>
                    </div>

                    <!-- Footer -->
                    <div class="sticky bottom-0 border-t border-gray-200 bg-white px-6 py-4 dark:border-gray-800 dark:bg-gray-900">
                        <div class="flex gap-3">
                            <button
                                type="button"
                                @click="aiResponseSheetOpen = false"
                                class="flex-1 rounded-lg border border-gray-200 bg-white px-4 py-2.5 text-sm font-medium text-gray-700 shadow-theme-xs hover:bg-gray-50 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-300 dark:hover:bg-gray-700"
                            >
                                Fermer
                            </button>
                            <button
                                type="button"
                                @click="useAIResponse()"
                                class="flex-1 rounded-lg bg-brand-500 px-4 py-2.5 text-sm font-medium text-white shadow-theme-xs hover:bg-brand-600"
                            >
                                Utiliser cette réponse
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- ====== Chat Section End ====== -->
</div>

<script>
function requestChatManager(requestId) {
    return {
        requestId: requestId,
        messageContent: '',
        messagesContainer: null,
        sending: false,
        uploading: false,
        pendingFile: null,
        imageModalOpen: false,
        imageModalSrc: '',
        // Enregistrement audio
        isRecording: false,
        mediaRecorder: null,
        audioStream: null,
        audioChunks: [],
        recordedAudioBlob: null,
        recordedAudioUrl: null,
        recordingTime: 0,
        recordingInterval: null,
        // Assistance IA
        aiAssistMode: false,
        selectedMessageIds: [],
        aiUserQuestion: '',
        aiResponse: '',
        aiGenerating: false,
        aiResponseSheetOpen: false,
        
        init() {
            // S'assurer que toutes les propriétés sont bien initialisées
            if (this.uploading === undefined) {
                this.uploading = false;
            }
            if (this.sending === undefined) {
                this.sending = false;
            }
            if (this.pendingFile === undefined) {
                this.pendingFile = null;
            }
            if (this.imageModalOpen === undefined) {
                this.imageModalOpen = false;
            }
            if (this.imageModalSrc === undefined) {
                this.imageModalSrc = '';
            }
            if (this.recordedAudioUrl === undefined) {
                this.recordedAudioUrl = null;
            }
            if (this.recordingTime === undefined) {
                this.recordingTime = 0;
            }
            
            this.messagesContainer = document.getElementById('messages-container');
            this.scrollToTop();
            
            // Se connecter à Firebase pour les messages en temps réel
            this.subscribeToFirebase();
            
            // Nettoyer l'enregistrement si l'utilisateur quitte la page
            window.addEventListener('beforeunload', () => {
                if (this.isRecording) {
                    this.stopAudioRecording();
                }
                // Nettoyer l'intervalle Firebase
                if (this.firebasePollInterval) {
                    clearInterval(this.firebasePollInterval);
                }
            });
        },
        
        scrollToTop() {
            if (this.messagesContainer) {
                this.messagesContainer.scrollTop = 0;
            }
        },
        
        async sendMessage() {
            if ((!this.messageContent.trim() && !this.pendingFile) || this.sending || this.uploading) return;
            
            // Si le mode IA est activé, appeler l'IA au lieu d'envoyer un message
            if (this.aiAssistMode) {
                // Utiliser le contenu du textarea comme question pour l'IA
                this.aiUserQuestion = this.messageContent.trim();
                // Vider le champ de saisie
                this.messageContent = '';
                // Appeler l'IA
                await this.requestAIAssist();
                // Désactiver le mode IA après l'appel
                this.aiAssistMode = false;
                return;
            }
            
            const content = this.messageContent.trim();
            const currentUser = {{ app.user ? app.user.id : 'null' }};
            
            // Optimistic update : afficher le message immédiatement
            const tempMessageId = 'temp-' + Date.now();
            const optimisticMessage = {
                id: tempMessageId,
                requestId: String(this.requestId),
                content: content,
                type: 'text',
                filePath: null,
                sender: {
                    id: currentUser,
                    firstName: '{{ app.user ? app.user.firstName : '' }}',
                    lastName: '{{ app.user ? app.user.lastName : '' }}',
                },
                createdAt: new Date().toISOString().slice(0, 19).replace('T', ' '),
                isRead: false,
            };
            
            // Afficher le message immédiatement
            this.handleNewMessage(optimisticMessage);
            
            // Vider le champ de saisie immédiatement
            this.messageContent = '';
            this.sending = true;
            
            try {
                const response = await fetch('{{ path('admin_requests_messages_create', {id: requestId}) }}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest',
                    },
                    body: JSON.stringify({
                        content: content || null,
                    }),
                });
                
                if (!response.ok) {
                    // En cas d'erreur, supprimer le message optimiste
                    const tempElement = this.messagesContainer?.querySelector(`[data-message-id="${tempMessageId}"]`);
                    if (tempElement) {
                        tempElement.remove();
                    }
                    
                    const errorData = await response.json().catch(() => ({ success: false, message: 'Erreur lors de l\'envoi' }));
                    const errorMessage = errorData.message || `Erreur ${response.status}: ${response.statusText}`;
                    if (window.showToast) {
                        window.showToast(errorMessage, 'error');
                    }
                    this.messageContent = content;
                    return;
                }
                
                const result = await response.json().catch(() => ({ success: false, message: 'Erreur lors de l\'envoi' }));
                
                if (result.success && result.data) {
                    // Remplacer le message optimiste par le vrai message
                    const tempElement = this.messagesContainer?.querySelector(`[data-message-id="${tempMessageId}"]`);
                    if (tempElement) {
                        tempElement.remove();
                    }
                    
                    // Afficher le vrai message avec les bonnes données
                    this.handleNewMessage(result.data);
                    
                    if (window.showToast) {
                        window.showToast('Message envoyé', 'success');
                    }
                } else {
                    // En cas d'erreur, supprimer le message optimiste
                    const tempElement = this.messagesContainer?.querySelector(`[data-message-id="${tempMessageId}"]`);
                    if (tempElement) {
                        tempElement.remove();
                    }
                    
                    const errorMessage = result.message || 'Erreur lors de l\'envoi du message';
                    if (window.showToast) {
                        window.showToast(errorMessage, 'error');
                    }
                    this.messageContent = content;
                }
            } catch (error) {
                // En cas d'erreur, supprimer le message optimiste
                const tempElement = this.messagesContainer?.querySelector(`[data-message-id="${tempMessageId}"]`);
                if (tempElement) {
                    tempElement.remove();
                }
                
                console.error('Erreur lors de l\'envoi du message:', error);
                if (window.showToast) {
                    window.showToast('Une erreur est survenue', 'error');
                }
                this.messageContent = content;
            } finally {
                this.sending = false;
            }
        },
        
        async handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            this.uploading = true;
            
            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('content', this.messageContent || '');
                
                const response = await fetch('{{ path('admin_requests_messages_create', {id: requestId}) }}', {
                    method: 'POST',
                    body: formData,
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Ne pas recharger la page, Firebase va mettre à jour en temps réel
                    if (window.showToast) {
                        window.showToast('Image envoyée', 'success');
                    }
                    // Optionnel : ajouter le message immédiatement à l'UI
                    if (data.data) {
                        this.handleNewMessage(data.data);
                    }
                } else {
                    if (window.showToast) {
                        window.showToast('Erreur: ' + data.message, 'error');
                    }
                }
            } catch (error) {
                console.error('Error uploading image:', error);
                if (window.showToast) {
                    window.showToast('Erreur lors de l\'upload de l\'image', 'error');
                }
            } finally {
                this.uploading = false;
                event.target.value = '';
            }
        },
        
        async handleCameraCapture(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                const base64Data = e.target.result.split(',')[1];
                const fileExtension = file.name.split('.').pop() || 'jpg';
                
                this.uploading = true;
                
                try {
                    const response = await fetch('{{ path('admin_requests_messages_create', {id: requestId}) }}', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            fileData: base64Data,
                            fileType: 'image',
                            fileExtension: fileExtension,
                            content: this.messageContent || null,
                        }),
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Ne pas recharger la page, Firebase va mettre à jour en temps réel
                        if (window.showToast) {
                            window.showToast('Photo envoyée', 'success');
                        }
                        // Optionnel : ajouter le message immédiatement à l'UI
                        if (data.data) {
                            this.handleNewMessage(data.data);
                        }
                    } else {
                        if (window.showToast) {
                            window.showToast('Erreur: ' + data.message, 'error');
                        }
                    }
                } catch (error) {
                    console.error('Error uploading photo:', error);
                    if (window.showToast) {
                        window.showToast('Erreur lors de l\'upload de la photo', 'error');
                    }
                } finally {
                    this.uploading = false;
                }
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        },
        
        async handleAudioUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            this.uploading = true;
            
            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('content', this.messageContent || '');
                
                const response = await fetch('{{ path('admin_requests_messages_create', {id: requestId}) }}', {
                    method: 'POST',
                    body: formData,
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Ne pas recharger la page, Firebase va mettre à jour en temps réel
                    if (window.showToast) {
                        window.showToast('Audio envoyé', 'success');
                    }
                    // Optionnel : ajouter le message immédiatement à l'UI
                    if (data.data) {
                        this.handleNewMessage(data.data);
                    }
                } else {
                    if (window.showToast) {
                        window.showToast('Erreur: ' + data.message, 'error');
                    }
                }
            } catch (error) {
                console.error('Error uploading audio:', error);
                if (window.showToast) {
                    window.showToast('Erreur lors de l\'upload de l\'audio', 'error');
                }
            } finally {
                this.uploading = false;
                event.target.value = '';
            }
        },
        
        async toggleAudioRecording() {
            if (this.isRecording) {
                this.stopAudioRecording();
            } else {
                await this.startAudioRecording();
            }
        },
        
        async startAudioRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                this.audioStream = stream;
                
                this.mediaRecorder = new MediaRecorder(stream);
                this.audioChunks = [];
                this.recordingTime = 0;
                
                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        this.audioChunks.push(event.data);
                    }
                };
                
                this.mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                    this.recordedAudioBlob = audioBlob;
                    this.recordedAudioUrl = URL.createObjectURL(audioBlob);
                    
                    // Arrêter tous les tracks du stream
                    if (this.audioStream) {
                        this.audioStream.getTracks().forEach(track => track.stop());
                        this.audioStream = null;
                    }
                    
                    // Afficher un modal pour prévisualiser et envoyer
                    this.showAudioPreview();
                };
                
                this.mediaRecorder.onerror = (event) => {
                    console.error('Erreur lors de l\'enregistrement:', event);
                    if (window.showToast) {
                        window.showToast('Erreur lors de l\'enregistrement', 'error');
                    }
                    this.stopAudioRecording();
                };
                
                this.mediaRecorder.start();
                this.isRecording = true;
                
                // Démarrer le compteur de temps
                this.recordingInterval = setInterval(() => {
                    this.recordingTime++;
                }, 1000);
                
                if (window.showToast) {
                    window.showToast('Enregistrement démarré', 'info');
                }
            } catch (error) {
                console.error('Erreur lors du démarrage de l\'enregistrement:', error);
                if (window.showToast) {
                    window.showToast('Impossible d\'accéder au microphone. Vérifiez les permissions.', 'error');
                }
                this.isRecording = false;
            }
        },
        
        stopAudioRecording() {
            if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                this.mediaRecorder.stop();
            }
            this.isRecording = false;
            
            // Arrêter le stream si toujours actif
            if (this.audioStream) {
                this.audioStream.getTracks().forEach(track => track.stop());
                this.audioStream = null;
            }
            
            if (this.recordingInterval) {
                clearInterval(this.recordingInterval);
                this.recordingInterval = null;
            }
        },
        
        showAudioPreview() {
            // Le modal sera affiché automatiquement grâce à x-show="recordedAudioUrl"
            // Pas besoin de confirm(), le modal s'affiche
        },
        
        cancelRecordedAudio() {
            // Nettoyer
            if (this.recordedAudioUrl) {
                URL.revokeObjectURL(this.recordedAudioUrl);
            }
            this.recordedAudioBlob = null;
            this.recordedAudioUrl = null;
            this.recordingTime = 0;
        },
        
        formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        },
        
        async sendRecordedAudio() {
            if (!this.recordedAudioBlob) return;
            
            this.uploading = true;
            
            try {
                // Convertir le blob en File avec le bon MIME type
                const audioFile = new File([this.recordedAudioBlob], `recording-${Date.now()}.webm`, {
                    type: 'audio/webm'
                });
                
                // Vérifier que le fichier est valide
                if (!audioFile || audioFile.size === 0) {
                    if (window.showToast) {
                        window.showToast('Erreur: Fichier audio invalide', 'error');
                    }
                    this.uploading = false;
                    return;
                }
                
                const formData = new FormData();
                formData.append('file', audioFile, audioFile.name);
                formData.append('content', this.messageContent || '');
                
                const response = await fetch('{{ path('admin_requests_messages_create', {id: requestId}) }}', {
                    method: 'POST',
                    body: formData,
                });
                
                // Vérifier si la réponse est OK avant de parser le JSON
                if (!response.ok) {
                    let errorMessage = 'Erreur lors de l\'envoi de l\'audio';
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.message || errorMessage;
                    } catch (e) {
                        errorMessage = `Erreur ${response.status}: ${response.statusText}`;
                    }
                    if (window.showToast) {
                        window.showToast(errorMessage, 'error');
                    }
                    this.uploading = false;
                    return;
                }
                
                const data = await response.json();
                
                if (data.success) {
                    // Nettoyer
                    if (this.recordedAudioUrl) {
                        URL.revokeObjectURL(this.recordedAudioUrl);
                    }
                    this.recordedAudioBlob = null;
                    this.recordedAudioUrl = null;
                    this.recordingTime = 0;
                    this.messageContent = '';
                    
                    // Ne pas recharger la page, Firebase va mettre à jour en temps réel
                    if (window.showToast) {
                        window.showToast('Audio envoyé', 'success');
                    }
                    // Optionnel : ajouter le message immédiatement à l'UI
                    if (data.data) {
                        this.handleNewMessage(data.data);
                    }
                } else {
                    if (window.showToast) {
                        window.showToast('Erreur: ' + (data.message || 'Erreur inconnue'), 'error');
                    }
                }
            } catch (error) {
                console.error('Error sending recorded audio:', error);
                if (window.showToast) {
                    window.showToast('Erreur lors de l\'envoi de l\'audio: ' + error.message, 'error');
                }
            } finally {
                this.uploading = false;
            }
        },
        
        openImageModal(imageSrc) {
            this.imageModalSrc = imageSrc;
            this.imageModalOpen = true;
        },
        
        closeImageModal() {
            this.imageModalOpen = false;
            this.imageModalSrc = '';
        },
        
        // Fonctions pour l'Assistance IA
        toggleAIAssist() {
            this.aiAssistMode = !this.aiAssistMode;
            if (!this.aiAssistMode) {
                // Réinitialiser quand on ferme
                this.selectedMessageIds = [];
                this.aiUserQuestion = '';
                this.aiResponse = '';
            }
        },
        
        async requestAIAssist() {
            if (!this.aiUserQuestion.trim() || this.aiGenerating) {
                if (!this.aiUserQuestion.trim()) {
                    if (window.showToast) {
                        window.showToast('Veuillez saisir une question', 'error');
                    }
                }
                return;
            }
            
            this.aiGenerating = true;
            this.aiResponse = '';
            
            try {
                const response = await fetch(`/admin/requests/${this.requestId}/ai-assist`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest',
                    },
                    body: JSON.stringify({
                        selectedMessageIds: this.selectedMessageIds.length > 0 ? this.selectedMessageIds.map(id => parseInt(id)) : [],
                        userQuestion: this.aiUserQuestion.trim() || null,
                        additionalContext: null,
                    }),
                });
                
                const result = await response.json().catch(() => ({ success: false, message: 'Erreur lors de la génération' }));
                
                if (response.ok && result.success) {
                    this.aiResponse = result.content || '';
                    this.aiResponseSheetOpen = true; // Ouvrir le rightsheet avec la réponse
                    if (window.showToast) {
                        window.showToast('Réponse générée avec succès', 'success');
                    }
                } else {
                    const errorMessage = result.message || 'Erreur lors de la génération de l\'assistance';
                    if (window.showToast) {
                        window.showToast(errorMessage, 'error');
                    }
                }
            } catch (error) {
                console.error('Erreur lors de la demande d\'assistance IA:', error);
                if (window.showToast) {
                    window.showToast('Erreur lors de la génération de l\'assistance', 'error');
                }
            } finally {
                this.aiGenerating = false;
            }
        },
        
        useAIResponse() {
            if (this.aiResponse) {
                this.messageContent = this.aiResponse;
                // Optionnel: fermer le mode assistance après utilisation
                // this.toggleAIAssist();
                if (window.showToast) {
                    window.showToast('Réponse copiée dans le champ de message', 'success');
                }
            }
        },
        
        async subscribeToFirebase() {
            try {
                // Récupérer la configuration Firebase
                const configResponse = await fetch('{{ path('admin_firebase_config') }}', {
                    headers: {
                        'Accept': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    credentials: 'same-origin'
                });
                
                if (!configResponse.ok) {
                    console.error('Failed to get Firebase config');
                    return;
                }
                
                const configData = await configResponse.json();
                
                if (!configData.success || !configData.config) {
                    console.error('Invalid Firebase config');
                    return;
                }

                // Initialiser Firebase si pas déjà fait
                if (typeof firebase !== 'undefined' && !firebase.apps.length) {
                    firebase.initializeApp(configData.config);
                }

                const database = firebase.database();
                
                // Vérifier que la base de données est accessible
                if (!database) {
                    console.error('❌ Firebase Database non disponible');
                    return;
                }
                
                // S'assurer que requestId est une string
                const requestIdStr = String(this.requestId);
                
                // Utiliser une référence avec un timestamp pour éviter les conflits avec les données existantes
                // On va écouter uniquement les messages publiés APRÈS la connexion
                const connectionTime = Date.now();
                const messagesRef = database.ref(`/requests/${requestIdStr}/messages`);
                
                console.log('🔍 Écoute configurée sur: /requests/' + requestIdStr + '/messages');
                console.log('⏰ Connexion établie à:', new Date(connectionTime).toLocaleTimeString());
                
                // Stocker la référence pour pouvoir la déconnecter si nécessaire
                this.firebaseMessagesRef = messagesRef;
                
                // Solution pour éviter l'erreur e.insert : utiliser un polling manuel
                // au lieu d'écouter directement (qui cause le bug d'indexation)
                let lastMessageKey = null;
                let lastMessageTime = Date.now();
                let knownMessageIds = new Set();
                
                // Fonction pour vérifier les nouveaux messages
                const checkForNewMessages = () => {
                    try {
                        // Récupérer les 5 derniers messages pour être sûr de ne pas rater un message
                        messagesRef.limitToLast(5).once('value', (snapshot) => {
                            if (snapshot.exists()) {
                                const messages = [];
                                snapshot.forEach((child) => {
                                    try {
                                        const data = child.val();
                                        if (!data || typeof data !== 'object') {
                                            return false;
                                        }
                                        
                                        const messageId = String(data?.id || child.key);
                                        const messageTime = data.createdAt ? new Date(data.createdAt).getTime() : Date.now();
                                        
                                        messages.push({
                                            key: child.key,
                                            id: messageId,
                                            time: messageTime,
                                            data: data,
                                            snapshot: child
                                        });
                                        
                                        return false;
                                    } catch (err) {
                                        return false;
                                    }
                                });
                                
                                // Trier par temps (plus récent en premier)
                                messages.sort((a, b) => b.time - a.time);
                                
                                // Traiter uniquement les nouveaux messages
                                let foundNew = false;
                                for (const msg of messages) {
                                    // Ignorer si déjà traité
                                    if (knownMessageIds.has(msg.id)) {
                                        continue;
                                    }
                                    
                                    // Vérifier si c'est un nouveau message (après le dernier check)
                                    if (msg.time > lastMessageTime || lastMessageKey === null) {
                                        console.log('🆕 Nouveau message détecté:', msg.id, 'à', new Date(msg.time).toLocaleTimeString());
                                        knownMessageIds.add(msg.id);
                                        
                                        // Extraire les données du snapshot et les normaliser
                                        const messageData = msg.data;
                                        // S'assurer que tous les IDs sont des strings
                                        if (messageData.id) messageData.id = String(messageData.id);
                                        if (messageData.requestId) messageData.requestId = String(messageData.requestId);
                                        if (messageData.receiverId) messageData.receiverId = String(messageData.receiverId);
                                        if (messageData.sender && messageData.sender.id) {
                                            messageData.sender.id = String(messageData.sender.id);
                                        }
                                        
                                        this.handleNewMessage(messageData);
                                        foundNew = true;
                                        
                                        // Mettre à jour la référence
                                        if (!lastMessageKey || msg.time > lastMessageTime) {
                                            lastMessageKey = msg.key;
                                            lastMessageTime = msg.time;
                                        }
                                    }
                                }
                                
                                if (!foundNew && messages.length > 0) {
                                    // Mettre à jour la référence même si pas de nouveau message
                                    const latest = messages[0];
                                    if (latest.time > lastMessageTime) {
                                        lastMessageKey = latest.key;
                                        lastMessageTime = latest.time;
                                    }
                                }
                            }
                        }, (error) => {
                            // Log uniquement les erreurs importantes
                            if (error && error.code !== 'PERMISSION_DENIED') {
                                console.warn('⚠️ Erreur polling Firebase:', error.message || error);
                            }
                        });
                    } catch (error) {
                        console.warn('⚠️ Erreur checkForNewMessages:', error.message || error);
                    }
                };
                
                // Vérifier immédiatement
                console.log('🔄 Premier check des messages...');
                checkForNewMessages();
                
                // Puis vérifier toutes les 1.5 secondes pour être plus réactif
                this.firebasePollInterval = setInterval(() => {
                    checkForNewMessages();
                }, 1500);
                
                console.log('✅ Polling Firebase configuré (vérification toutes les 1.5 secondes)');
                
                console.log('✅ Connecté à Firebase pour les messages de la demande', this.requestId);
                console.log('📡 Écoute active sur /requests/' + this.requestId + '/messages');
            } catch (error) {
                console.error('Error setting up Firebase:', error);
            }
        },
        
        handleNewMessage(data) {
            // Vérifier que le message appartient bien à cette demande
            if (data.requestId && parseInt(data.requestId) !== parseInt(this.requestId)) {
                return;
            }
            
            // Vérifier si le message existe déjà (éviter les doublons)
            const existingMessage = this.messagesContainer?.querySelector(`[data-message-id="${data.id}"]`);
            if (existingMessage) {
                return;
            }
            
            // Déterminer si le message vient de l'utilisateur actuel
            const currentUser = {{ app.user ? app.user.id : 'null' }};
            const isFromMe = data.sender && currentUser && parseInt(data.sender.id) === parseInt(currentUser);
            
            // Créer l'élément HTML du message
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${isFromMe ? 'justify-end' : 'justify-start'} gap-2`;
            messageDiv.setAttribute('data-message-id', data.id);
            messageDiv.setAttribute('data-message-type', data.type || 'text');
            
            let messageContentHtml = '';
            
            if (data.type === 'image' && data.filePath) {
                const imagePath = data.filePath;
                messageContentHtml = `
                    <img 
                        src="${imagePath}" 
                        alt="Image" 
                        class="max-w-full h-auto rounded cursor-pointer hover:opacity-90 transition-opacity request-message-image"
                        data-image-path="${imagePath}"
                        style="max-height: 300px;"
                    />
                    ${data.content ? `<p class="text-sm mt-2 ${isFromMe ? 'text-black' : '!text-gray-950 dark:!text-gray-100'}">${this.escapeHtml(data.content)}</p>` : ''}
                `;
            } else if (data.type === 'audio' && data.filePath) {
                messageContentHtml = `
                    <div class="flex items-center gap-2">
                        <audio 
                            controls 
                            class="w-full max-w-xs" 
                            style="min-width: 250px; height: 40px;"
                            preload="metadata"
                            data-audio-id="${data.id}"
                        >
                            <source src="${data.filePath}" type="audio/webm">
                            <source src="${data.filePath}" type="audio/mpeg">
                            <source src="${data.filePath}" type="audio/wav">
                            <source src="${data.filePath}" type="audio/ogg">
                            <source src="${data.filePath}" type="audio/mp3">
                            Votre navigateur ne supporte pas l'élément audio.
                        </audio>
                    </div>
                    ${data.content ? `<p class="text-sm mt-2 ${isFromMe ? 'text-black' : '!text-gray-950 dark:!text-gray-100'}">${this.escapeHtml(data.content)}</p>` : ''}
                `;
            } else {
                messageContentHtml = `
                    <p class="text-sm whitespace-pre-wrap ${isFromMe ? 'text-black' : '!text-gray-950 dark:!text-gray-100'}">
                        ${data.content ? this.escapeHtml(data.content) : '<span class="italic opacity-75 ' + (isFromMe ? 'text-black' : 'text-gray-600 dark:text-gray-400') + '">(Message vide)</span>'}
                    </p>
                `;
            }
            
            // Structure du message avec checkbox conditionnelle
            const checkboxContainer = this.aiAssistMode ? `
                <div class="flex items-start pt-6" x-show="aiAssistMode">
                    <input
                        type="checkbox"
                        value="${data.id}"
                        x-model="selectedMessageIds"
                        class="h-4 w-4 rounded border-gray-300 text-brand-500 focus:ring-brand-500 dark:border-gray-700"
                    />
                </div>
            ` : '';
            
            messageDiv.innerHTML = `
                ${checkboxContainer}
                <div class="flex max-w-[70%] flex-col ${isFromMe ? 'items-end' : 'items-start'}">
                    <span class="mb-1 text-xs text-gray-500 dark:text-gray-400">
                        ${data.sender ? `${this.escapeHtml(data.sender.firstName)} ${this.escapeHtml(data.sender.lastName)}` : 'Utilisateur'}
                    </span>
                    <div class="rounded-lg px-4 py-2 ${isFromMe ? 'bg-brand-600' : 'bg-gray-100 dark:bg-gray-700'}">
                        ${messageContentHtml}
                    </div>
                    <span class="mt-1 text-xs text-gray-500 dark:text-gray-400">
                        ${data.createdAt ? new Date(data.createdAt).toLocaleString('fr-FR') : ''}
                    </span>
                </div>
            `;
            
            // Ajouter le message au conteneur (en haut pour les nouveaux messages)
            if (this.messagesContainer) {
                // Insérer le nouveau message en haut du conteneur
                const firstChild = this.messagesContainer.firstChild;
                if (firstChild) {
                    this.messagesContainer.insertBefore(messageDiv, firstChild);
                } else {
                    this.messagesContainer.appendChild(messageDiv);
                }
                
                // Ajouter l'event listener pour les images
                const imageElement = messageDiv.querySelector('.request-message-image');
                if (imageElement) {
                    imageElement.addEventListener('click', () => {
                        this.openImageModal(imageElement.getAttribute('data-image-path'));
                    });
                }
                
                // Réinitialiser Alpine.js pour que les directives x-show et x-model fonctionnent
                if (window.Alpine) {
                    window.Alpine.initTree(messageDiv);
                }
                
                // Scroller vers le haut pour voir le nouveau message
                this.scrollToTop();
            }
        },
        
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },
    };
}

// Script pour forcer le chargement de la durée des fichiers audio
document.addEventListener('DOMContentLoaded', function() {
    const audioElements = document.querySelectorAll('audio[data-audio-id]');
    audioElements.forEach(function(audio) {
        // Forcer le chargement des métadonnées
        audio.load();
        
        // Attendre que les métadonnées soient chargées
        audio.addEventListener('loadedmetadata', function() {
            if (this.duration && !isNaN(this.duration) && this.duration > 0) {
                console.log('Durée audio chargée:', this.duration, 'secondes pour audio ID:', this.dataset.audioId);
            }
        });
        
        // Si les métadonnées ne se chargent pas, essayer de charger un peu du fichier
        audio.addEventListener('canplay', function() {
            if (this.duration && !isNaN(this.duration) && this.duration > 0) {
                console.log('Durée audio disponible:', this.duration, 'secondes pour audio ID:', this.dataset.audioId);
            } else {
                // Si la durée n'est toujours pas disponible, essayer de jouer un peu
                const playPromise = this.play();
                if (playPromise !== undefined) {
                    playPromise.then(function() {
                        audio.pause();
                        audio.currentTime = 0;
                    }).catch(function(error) {
                        console.error('Erreur lors du chargement de la durée audio:', error);
                    });
                }
            }
        });
    });
});
</script>
{% endblock %}

