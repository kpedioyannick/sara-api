{% extends 'tailadmin/layouts/base.html.twig' %}

{% block page_title %}{{ pageTitle }}{% endblock %}

{% block content %}
<div class="mx-auto max-w-screen-2xl p-4 md:p-6 2xl:p-10">
    {% include 'tailadmin/components/breadcrumb.html.twig' with { items: breadcrumbs } %}

    <!-- ====== Chat Section Start ====== -->
    <div class="rounded-lg border border-gray-200 bg-white shadow-default dark:border-gray-800 dark:bg-gray-900">
        <!-- Header -->
        <div class="border-b border-gray-200 px-6 py-4 dark:border-gray-800">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <a href="{{ path('admin_messages_list') }}" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                        <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                        </svg>
                    </a>
                    <div class="flex h-10 w-10 items-center justify-center rounded-full bg-gray-200 dark:bg-gray-700">
                        <span class="font-semibold text-gray-600 dark:text-gray-300">
                            {{ otherUser.firstName|first|upper }}{{ otherUser.lastName|first|upper }}
                        </span>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-800 dark:text-white">
                            {{ otherUser.firstName }} {{ otherUser.lastName }}
                        </h3>
                        <p class="text-xs text-gray-500 dark:text-gray-400">{{ otherUser.email }}</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Messages Area -->
        <div class="flex h-[600px] flex-col">
            <!-- Messages List -->
            <div
                id="messages-container"
                class="flex-1 space-y-4 overflow-y-auto p-6"
                x-data="chatManager('{{ conversationId }}')"
                x-init="init()"
            >
                {% for message in messages %}
                    <div class="flex {% if message.isFromMe %}justify-end{% else %}justify-start{% endif %}">
                        <div class="flex max-w-[70%] flex-col {% if message.isFromMe %}items-end{% else %}items-start{% endif %}">
                            {% if not message.isFromMe %}
                                <span class="mb-1 text-xs text-gray-500 dark:text-gray-400">
                                    {{ message.sender.firstName }} {{ message.sender.lastName }}
                                </span>
                            {% endif %}
                            <div
                                class="rounded-lg px-4 py-2 {% if message.isFromMe %}bg-brand-500 text-white{% else %}bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-white{% endif %}"
                            >
                                <p class="text-sm">{{ message.content }}</p>
                            </div>
                            <span class="mt-1 text-xs text-gray-400 dark:text-gray-500">
                                {{ message.createdAt|date('d/m/Y H:i') }}
                            </span>
                        </div>
                    </div>
                {% endfor %}
            </div>

            <!-- Message Input -->
            <div class="border-t border-gray-200 p-4 dark:border-gray-800">
                <form @submit.prevent="sendMessage()" class="flex gap-2">
                    <input
                        type="text"
                        x-model="messageContent"
                        placeholder="Tapez votre message..."
                        class="flex-1 rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm focus:border-brand-500 focus:outline-none focus:ring-2 focus:ring-brand-500 dark:border-gray-700 dark:bg-gray-800 dark:text-white"
                        required
                    />
                    <button
                        type="submit"
                        class="rounded-lg bg-brand-500 px-6 py-2 text-sm font-medium text-white hover:bg-brand-600 focus:outline-none focus:ring-2 focus:ring-brand-500 focus:ring-offset-2"
                    >
                        Envoyer
                    </button>
                </form>
            </div>
        </div>
    </div>
    <!-- ====== Chat Section End ====== -->
</div>

<script>
function chatManager(conversationId) {
    return {
        conversationId: conversationId,
        messageContent: '',
        messagesContainer: null,
        eventSource: null,
        
        init() {
            this.messagesContainer = document.getElementById('messages-container');
            this.scrollToBottom();
            
            // Marquer les messages comme lus immédiatement
            this.markAsRead();
            
            // S'abonner aux messages en temps réel via Mercure
            this.subscribeToMercure();
        },
        
        async subscribeToMercure() {
            try {
                // Récupérer le token JWT Mercure depuis le serveur
                const tokenResponse = await fetch('{{ path('admin_messages_mercure_token') }}');
                const tokenData = await tokenResponse.json();
                
                if (!tokenData.success) {
                    console.error('Failed to get Mercure token');
                    // Fallback: rafraîchir manuellement
                    setInterval(() => this.refreshMessages(), 5000);
                    return;
                }
                
                const mercureUrl = '{{ mercureUrl }}';
                const topic = `/conversations/${this.conversationId}`;
                
                // URL avec le topic et le token JWT
                const url = new URL(mercureUrl);
                url.searchParams.append('topic', topic);
                
                // Créer l'EventSource pour SSE (Server-Sent Events)
                // Note: EventSource ne supporte pas directement les headers Authorization
                // Pour une authentification complète, utilisez l'URL avec le token en paramètre
                // ou utilisez fetch avec EventSource polyfill
                this.eventSource = new EventSource(`${url.toString()}&authorization=Bearer ${tokenData.token}`);
                
                this.eventSource.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleNewMessage(data);
                };
                
                this.eventSource.onerror = (error) => {
                    console.error('Mercure connection error:', error);
                    // Fallback: rafraîchir manuellement si Mercure échoue
                    setInterval(() => {
                        this.refreshMessages();
                    }, 5000);
                };
            } catch (error) {
                console.error('Error setting up Mercure:', error);
                // Fallback: rafraîchir manuellement
                setInterval(() => this.refreshMessages(), 5000);
            }
        },
        
        handleNewMessage(data) {
            // Vérifier si le message n'existe pas déjà
            const messageExists = Array.from(this.messagesContainer.children).some(
                el => el.dataset.messageId === data.id?.toString()
            );
            
            if (!messageExists) {
                const isFromMe = data.sender?.id === {{ app.user.id }};
                this.addMessageToUI({
                    id: data.id,
                    content: data.content,
                    isFromMe: isFromMe,
                    createdAt: data.createdAt,
                    sender: data.sender || {
                        firstName: '{{ app.user.firstName }}',
                        lastName: '{{ app.user.lastName }}',
                    },
                });
            }
        },
        
        async sendMessage() {
            if (!this.messageContent.trim()) {
                return;
            }

            const content = this.messageContent.trim();
            this.messageContent = '';

            try {
                const response = await fetch('{{ path('admin_messages_create') }}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        content: content,
                        receiverId: {{ otherUser.id }},
                        conversationId: this.conversationId,
                    }),
                });

                const data = await response.json();
                
                if (data.success) {
                    // Ajouter le message à l'interface
                    this.addMessageToUI({
                        id: data.data.id,
                        content: content,
                        isFromMe: true,
                        createdAt: data.data.createdAt,
                        sender: {
                            firstName: '{{ app.user.firstName }}',
                            lastName: '{{ app.user.lastName }}',
                        },
                    });
                    
                    // Le message sera reçu via Mercure automatiquement
                    // Pas besoin de refresh manuel
                } else {
                    if (window.showToast) {
                        window.showToast('Erreur: ' + data.message, 'error');
                    }
                    this.messageContent = content;
                }
            } catch (error) {
                console.error('Error sending message:', error);
                if (window.showToast) {
                    window.showToast('Erreur lors de l\'envoi du message', 'error');
                }
                this.messageContent = content;
            }
        },
        
        async refreshMessages() {
            // Cette méthode n'est plus nécessaire avec Mercure, mais on la garde comme fallback
            try {
                // Recharger la page pour récupérer les nouveaux messages
                // Ou faire un fetch vers une API de refresh
                console.log('Fallback: refreshing messages manually');
            } catch (error) {
                console.error('Error refreshing messages:', error);
            }
        },
        
        addMessageToUI(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${message.isFromMe ? 'justify-end' : 'justify-start'}`;
            messageDiv.dataset.messageId = message.id;
            messageDiv.innerHTML = `
                <div class="flex max-w-[70%] flex-col ${message.isFromMe ? 'items-end' : 'items-start'}">
                    ${!message.isFromMe ? `
                        <span class="mb-1 text-xs text-gray-500 dark:text-gray-400">
                            ${message.sender.firstName} ${message.sender.lastName}
                        </span>
                    ` : ''}
                    <div class="rounded-lg px-4 py-2 ${message.isFromMe ? 'bg-brand-500 text-white' : 'bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-white'}">
                        <p class="text-sm">${this.escapeHtml(message.content)}</p>
                    </div>
                    <span class="mt-1 text-xs text-gray-400 dark:text-gray-500">
                        ${this.formatDate(message.createdAt)}
                    </span>
                </div>
            `;
            this.messagesContainer.appendChild(messageDiv);
            this.scrollToBottom();
        },
        
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },
        
        async markAsRead() {
            try {
                await fetch(`{{ path('admin_messages_mark_read', { conversationId: conversationId }) }}`, {
                    method: 'POST',
                });
            } catch (error) {
                console.error('Error marking as read:', error);
            }
        },
        
        scrollToBottom() {
            if (this.messagesContainer) {
                this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            }
        },
        
        formatDate(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diff = now - date;
            const minutes = Math.floor(diff / 60000);
            
            if (minutes < 1) return 'À l\'instant';
            if (minutes < 60) return `Il y a ${minutes} min`;
            if (minutes < 1440) return `Il y a ${Math.floor(minutes / 60)}h`;
            
            return date.toLocaleDateString('fr-FR', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
            });
        }
    }
}
</script>
{% endblock %}

