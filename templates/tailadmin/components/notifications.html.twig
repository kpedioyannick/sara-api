{# Composant de notifications avec badge et panneau déroulant #}
<div
  class="relative"
  x-data="notificationManager()"
  x-init="init()"
  @click.outside="panelOpen = false"
>
  <!-- Bouton avec badge -->
  <button
    @click="togglePanel()"
    class="relative flex h-11 w-11 items-center justify-center rounded-full border border-gray-200 bg-white text-gray-500 transition-colors hover:bg-gray-100 hover:text-gray-700 dark:border-gray-800 dark:bg-gray-900 dark:text-gray-400 dark:hover:bg-gray-800 dark:hover:text-white"
  >
    <span
      x-show="unreadCount > 0"
      x-text="unreadCount > 99 ? '99+' : unreadCount"
      class="absolute -top-1 -right-1 z-10 flex h-5 w-5 items-center justify-center rounded-full bg-red-600 text-xs font-bold text-white"
      style="display: none;"
    ></span>
    <svg
      class="fill-current"
      width="20"
      height="20"
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M10.75 2.29248C10.75 1.87827 10.4143 1.54248 10 1.54248C9.58583 1.54248 9.25004 1.87827 9.25004 2.29248V2.83613C6.08266 3.20733 3.62504 5.9004 3.62504 9.16748V14.4591H3.33337C2.91916 14.4591 2.58337 14.7949 2.58337 15.2091C2.58337 15.6234 2.91916 15.9591 3.33337 15.9591H4.37504H15.625H16.6667C17.0809 15.9591 17.4167 15.6234 17.4167 15.2091C17.4167 14.7949 17.0809 14.4591 16.6667 14.4591H16.375V9.16748C16.375 5.9004 13.9174 3.20733 10.75 2.83613V2.29248ZM14.875 14.4591V9.16748C14.875 6.47509 12.6924 4.29248 10 4.29248C7.30765 4.29248 5.12504 6.47509 5.12504 9.16748V14.4591H14.875ZM8.00004 17.7085C8.00004 18.1228 8.33583 18.4585 8.75004 18.4585H11.25C11.6643 18.4585 12 18.1228 12 17.7085C12 17.2943 11.6643 16.9585 11.25 16.9585H8.75004C8.33583 16.9585 8.00004 17.2943 8.00004 17.7085Z"
        fill=""
      />
    </svg>
  </button>

  <!-- Panneau de notifications -->
  <div
    x-show="panelOpen"
    x-transition:enter="transition ease-out duration-200"
    x-transition:enter-start="opacity-0 scale-95"
    x-transition:enter-end="opacity-100 scale-100"
    x-transition:leave="transition ease-in duration-150"
    x-transition:leave-start="opacity-100 scale-100"
    x-transition:leave-end="opacity-0 scale-95"
    class="absolute right-0 mt-2 w-96 rounded-lg border border-gray-200 bg-white shadow-lg z-50 dark:bg-gray-800 dark:border-gray-700"
    style="display: none; max-height: 600px; overflow-y: auto;"
  >
    <!-- En-tête du panneau -->
    <div class="sticky top-0 z-10 border-b border-gray-200 bg-white dark:border-gray-700 dark:bg-gray-800">
      <div class="flex items-center justify-between px-4 py-3">
        <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Notifications</h3>
        <div class="flex items-center gap-2">
          <button
            @click="markAllAsRead()"
            x-show="unreadCount > 0"
            class="text-sm text-brand-600 hover:text-brand-700 dark:text-brand-400"
            style="display: none;"
          >
            Tout marquer comme lu
          </button>
          <button
            @click="panelOpen = false"
            class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
          >
            <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>
      
      <!-- Filtres par catégorie -->
      <div class="flex gap-1 px-4 pb-2 border-b border-gray-200 dark:border-gray-700">
        <button
          @click="activeFilter = 'all'"
          :class="activeFilter === 'all' ? 'bg-brand-100 text-brand-700 dark:bg-brand-900/30 dark:text-brand-400' : 'text-gray-600 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700'"
          class="px-3 py-1.5 text-xs font-medium rounded-md transition-colors"
        >
          Toutes
          <span x-show="getUnreadCountByCategory('all') > 0" x-text="'(' + getUnreadCountByCategory('all') + ')'" class="ml-1"></span>
        </button>
        <button
          @click="activeFilter = 'message'"
          :class="activeFilter === 'message' ? 'bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400' : 'text-gray-600 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700'"
          class="px-3 py-1.5 text-xs font-medium rounded-md transition-colors"
        >
          Messages
          <span x-show="getUnreadCountByCategory('message') > 0" x-text="'(' + getUnreadCountByCategory('message') + ')'" class="ml-1"></span>
        </button>
        <button
          @click="activeFilter = 'task'"
          :class="activeFilter === 'task' ? 'bg-orange-100 text-orange-700 dark:bg-orange-900/30 dark:text-orange-400' : 'text-gray-600 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700'"
          class="px-3 py-1.5 text-xs font-medium rounded-md transition-colors"
        >
          Tâches
          <span x-show="getUnreadCountByCategory('task') > 0" x-text="'(' + getUnreadCountByCategory('task') + ')'" class="ml-1"></span>
        </button>
        <button
          @click="activeFilter = 'other'"
          :class="activeFilter === 'other' ? 'bg-gray-100 text-gray-700 dark:bg-gray-700 dark:text-gray-300' : 'text-gray-600 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700'"
          class="px-3 py-1.5 text-xs font-medium rounded-md transition-colors"
        >
          Autres
          <span x-show="getUnreadCountByCategory('other') > 0" x-text="'(' + getUnreadCountByCategory('other') + ')'" class="ml-1"></span>
        </button>
      </div>
    </div>

    <!-- Liste des notifications -->
    <div class="divide-y divide-gray-200 dark:divide-gray-700">
      <template x-if="filteredNotifications.length === 0">
        <div class="py-8 text-center">
          <p class="text-sm text-gray-500 dark:text-gray-400">Aucune notification</p>
        </div>
      </template>
      <template x-for="notification in filteredNotifications" :key="notification.id">
        <div
          @click="openNotification(notification)"
          :class="notification.isRead ? 'bg-white dark:bg-gray-800' : getNotificationBgClass(notification.category)"
          class="flex items-start gap-3 p-4 hover:bg-gray-50 dark:hover:bg-gray-700 cursor-pointer transition-colors"
        >
          <!-- Icône selon la catégorie -->
          <div :class="getNotificationIconClass(notification.category)" class="flex-shrink-0 mt-0.5">
            <span x-html="getNotificationIcon(notification.category, notification.type)"></span>
          </div>
          
          <div class="flex-1 min-w-0">
            <div class="flex items-start justify-between gap-2">
              <p class="text-sm font-medium text-gray-900 dark:text-white" x-text="notification.title"></p>
              <button
                @click.stop="deleteNotification(notification.id)"
                class="flex-shrink-0 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            <p class="text-xs text-gray-500 dark:text-gray-400 mt-1" x-text="notification.message || ''"></p>
            <p class="text-xs text-gray-400 dark:text-gray-500 mt-1" x-text="formatDate(notification.createdAt)"></p>
          </div>
        </div>
      </template>
    </div>

    <!-- Pied du panneau -->
    <div class="sticky bottom-0 border-t border-gray-200 bg-white px-4 py-3 text-center dark:border-gray-700 dark:bg-gray-800">
      <a
        href="{{ path('admin_notifications_list') }}"
        class="text-sm text-brand-600 hover:text-brand-700 dark:text-brand-400"
      >
        Voir toutes les notifications
      </a>
    </div>
  </div>
</div>

<script>
function notificationManager() {
  return {
    panelOpen: false,
    notifications: [],
    unreadCount: 0,
    activeFilter: 'all',
    firebaseDatabase: null,
    firebaseConfig: null,
    userId: {{ app.user.id }},

    get filteredNotifications() {
      if (this.activeFilter === 'all') {
        return this.notifications;
      }
      return this.notifications.filter(n => n.category === this.activeFilter);
    },

    async init() {
      await this.loadUnreadCount();
      await this.loadNotifications();
      await this.initFirebase();
    },

    async loadUnreadCount() {
      try {
        const response = await fetch('{{ path('api_notifications_unread_count') }}');
        const data = await response.json();
        this.unreadCount = data.count || 0;
      } catch (error) {
        console.error('Erreur chargement compteur notifications:', error);
      }
    },

    async loadNotifications() {
      try {
        const response = await fetch('{{ path('api_notifications_list') }}?limit=20');
        const data = await response.json();
        if (data.notifications) {
          this.notifications = data.notifications;
        }
      } catch (error) {
        console.error('Erreur chargement notifications:', error);
      }
    },

    async initFirebase() {
      try {
        // Récupérer la configuration Firebase depuis le serveur
        const configResponse = await fetch('{{ path('admin_firebase_config') }}', {
          headers: {
            'Accept': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
          },
          credentials: 'same-origin'
        });
        
        if (!configResponse.ok) {
          console.error('Échec récupération config Firebase');
          return;
        }

        const configData = await configResponse.json();
        
        if (!configData.success || !configData.config) {
          console.error('Configuration Firebase invalide');
          return;
        }

        this.firebaseConfig = configData.config;

        // Initialiser Firebase
        if (typeof firebase !== 'undefined') {
          firebase.initializeApp(this.firebaseConfig);
          this.firebaseDatabase = firebase.database();

          // Écouter les nouvelles notifications
          const notificationsRef = this.firebaseDatabase.ref(`/notifications/user/${this.userId}/notifications`);
          notificationsRef.limitToLast(1).on('child_added', (snapshot) => {
            const notification = snapshot.val();
            this.handleRealtimeNotification(notification);
          });

          // Écouter les mises à jour
          const updatesRef = this.firebaseDatabase.ref(`/notifications/user/${this.userId}/updates`);
          updatesRef.limitToLast(1).on('child_added', (snapshot) => {
            const update = snapshot.val();
            this.handleRealtimeUpdate(update);
          });

          console.log('✅ Connecté à Firebase pour les notifications temps réel');
        } else {
          console.error('Firebase SDK non chargé');
        }
      } catch (error) {
        console.error('Erreur initialisation Firebase:', error);
      }
    },
    
    handleRealtimeUpdate(update) {
      if (update.type === 'all_read') {
        this.notifications.forEach(n => n.isRead = true);
        this.unreadCount = 0;
      } else if (update.type === 'notification_read') {
        const notification = this.notifications.find(n => n.id === update.id);
        if (notification) {
          notification.isRead = true;
          if (this.unreadCount > 0) this.unreadCount--;
        }
      } else if (update.type === 'notification_deleted') {
        this.notifications = this.notifications.filter(n => n.id !== update.id);
        this.loadUnreadCount();
      }
    },

    handleRealtimeNotification(data) {
      if (data.type === 'all_read') {
        this.notifications.forEach(n => n.isRead = true);
        this.unreadCount = 0;
        return;
      }

      if (data.type === 'notification_read') {
        const notification = this.notifications.find(n => n.id === data.id);
        if (notification) {
          notification.isRead = true;
          if (this.unreadCount > 0) {
            this.unreadCount--;
          }
        }
        return;
      }

      if (data.type === 'notification_deleted') {
        this.notifications = this.notifications.filter(n => n.id !== data.id);
        return;
      }

      // Nouvelle notification
      if (data.id) {
        this.notifications.unshift(data);
        if (!data.isRead) {
          this.unreadCount++;
        }
        // Limiter à 20 notifications dans le panneau
        if (this.notifications.length > 20) {
          this.notifications = this.notifications.slice(0, 20);
        }
        // Afficher une notification toast si disponible
        this.showToast(data);
      }
    },

    showToast(notification) {
      // Utiliser le système de toast existant si disponible
      if (window.showToast) {
        window.showToast(notification.title, 'info', {
          onClick: () => {
            if (notification.url) {
              window.location.href = notification.url;
            }
          }
        });
      }
    },

    togglePanel() {
      this.panelOpen = !this.panelOpen;
      if (this.panelOpen) {
        this.loadNotifications();
      }
    },

    async openNotification(notification) {
      // Marquer comme lu si ce n'est pas déjà fait
      if (!notification.isRead) {
        await this.markAsRead(notification.id);
      }
      
      // Rediriger vers l'URL de la notification
      if (notification.url) {
        window.location.href = notification.url;
      }
    },

    async markAsRead(notificationId) {
      try {
        const response = await fetch(`{{ path('api_notifications_mark_read', {id: 'PLACEHOLDER'}) }}`.replace('PLACEHOLDER', notificationId), {
          method: 'POST',
          headers: {
            'X-Requested-With': 'XMLHttpRequest'
          }
        });
        
        if (response.ok) {
          const notification = this.notifications.find(n => n.id === notificationId);
          if (notification && !notification.isRead) {
            notification.isRead = true;
            if (this.unreadCount > 0) {
              this.unreadCount--;
            }
          }
        }
      } catch (error) {
        console.error('Erreur marquage comme lu:', error);
      }
    },

    async markAllAsRead() {
      try {
        const response = await fetch('{{ path('api_notifications_mark_all_read') }}', {
          method: 'POST',
          headers: {
            'X-Requested-With': 'XMLHttpRequest'
          }
        });
        
        if (response.ok) {
          this.notifications.forEach(n => n.isRead = true);
          this.unreadCount = 0;
        }
      } catch (error) {
        console.error('Erreur marquage tout comme lu:', error);
      }
    },

    async deleteNotification(notificationId) {
      try {
        const response = await fetch(`{{ path('api_notifications_delete', {id: 'PLACEHOLDER'}) }}`.replace('PLACEHOLDER', notificationId), {
          method: 'DELETE',
          headers: {
            'X-Requested-With': 'XMLHttpRequest'
          }
        });
        
        if (response.ok) {
          const notification = this.notifications.find(n => n.id === notificationId);
          if (notification && !notification.isRead) {
            if (this.unreadCount > 0) {
              this.unreadCount--;
            }
          }
          this.notifications = this.notifications.filter(n => n.id !== notificationId);
        }
      } catch (error) {
        console.error('Erreur suppression notification:', error);
      }
    },

    getUnreadCountByCategory(category) {
      if (category === 'all') {
        return this.unreadCount;
      }
      return this.notifications.filter(n => !n.isRead && n.category === category).length;
    },

    getNotificationBgClass(category) {
      switch(category) {
        case 'message':
          return 'bg-blue-50 dark:bg-blue-900/20';
        case 'task':
          return 'bg-orange-50 dark:bg-orange-900/20';
        default:
          return 'bg-gray-50 dark:bg-gray-900/20';
      }
    },

    getNotificationIconClass(category) {
      switch(category) {
        case 'message':
          return 'text-blue-600 dark:text-blue-400';
        case 'task':
          return 'text-orange-600 dark:text-orange-400';
        default:
          return 'text-gray-600 dark:text-gray-400';
      }
    },

    getNotificationIcon(category, type) {
      // Icônes SVG pour chaque catégorie
      if (category === 'message') {
        return '<svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" /></svg>';
      }
      
      if (category === 'task') {
        if (type === 'deadline_reminder') {
          return '<svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>';
        }
        return '<svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" /></svg>';
      }
      
      // Icône par défaut
      return '<svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" /></svg>';
    },

    formatDate(dateString) {
      if (!dateString) return '';
      
      try {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);
        
        if (diffMins < 1) return 'À l\'instant';
        if (diffMins < 60) return `Il y a ${diffMins} min`;
        if (diffHours < 24) return `Il y a ${diffHours} h`;
        if (diffDays < 7) return `Il y a ${diffDays} j`;
        
        return date.toLocaleDateString('fr-FR', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      } catch (e) {
        return dateString;
      }
    }
  };
}
</script>
