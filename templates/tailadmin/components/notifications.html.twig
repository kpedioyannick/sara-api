{# Composant de notifications avec badge et panneau déroulant #}
<div
  class="relative"
  x-data="notificationManager()"
  x-init="init()"
  @click.outside="panelOpen = false"
>
  <!-- Bouton avec badge -->
  <button
    @click="togglePanel()"
    class="relative flex h-11 w-11 items-center justify-center rounded-full border border-gray-200 bg-white text-gray-500 transition-colors hover:bg-gray-100 hover:text-gray-700 dark:border-gray-800 dark:bg-gray-900 dark:text-gray-400 dark:hover:bg-gray-800 dark:hover:text-white"
  >
    <span
      x-show="unreadCount > 0"
      x-text="unreadCount > 99 ? '99+' : unreadCount"
      class="absolute -top-1 -right-1 z-10 flex h-5 w-5 items-center justify-center rounded-full bg-red-600 text-xs font-bold text-white"
      style="display: none;"
    ></span>
    <svg
      class="fill-current"
      width="20"
      height="20"
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M10.75 2.29248C10.75 1.87827 10.4143 1.54248 10 1.54248C9.58583 1.54248 9.25004 1.87827 9.25004 2.29248V2.83613C6.08266 3.20733 3.62504 5.9004 3.62504 9.16748V14.4591H3.33337C2.91916 14.4591 2.58337 14.7949 2.58337 15.2091C2.58337 15.6234 2.91916 15.9591 3.33337 15.9591H4.37504H15.625H16.6667C17.0809 15.9591 17.4167 15.6234 17.4167 15.2091C17.4167 14.7949 17.0809 14.4591 16.6667 14.4591H16.375V9.16748C16.375 5.9004 13.9174 3.20733 10.75 2.83613V2.29248ZM14.875 14.4591V9.16748C14.875 6.47509 12.6924 4.29248 10 4.29248C7.30765 4.29248 5.12504 6.47509 5.12504 9.16748V14.4591H14.875ZM8.00004 17.7085C8.00004 18.1228 8.33583 18.4585 8.75004 18.4585H11.25C11.6643 18.4585 12 18.1228 12 17.7085C12 17.2943 11.6643 16.9585 11.25 16.9585H8.75004C8.33583 16.9585 8.00004 17.2943 8.00004 17.7085Z"
        fill=""
      />
    </svg>
  </button>

  <!-- Panneau de notifications -->
  <div
    x-show="panelOpen"
    x-transition:enter="transition ease-out duration-200"
    x-transition:enter-start="opacity-0 scale-95"
    x-transition:enter-end="opacity-100 scale-100"
    x-transition:leave="transition ease-in duration-150"
    x-transition:leave-start="opacity-100 scale-100"
    x-transition:leave-end="opacity-0 scale-95"
    class="absolute right-0 mt-2 w-96 rounded-lg border border-gray-200 bg-white shadow-lg z-50 dark:bg-gray-800 dark:border-gray-700"
    style="display: none; max-height: 600px; overflow-y: auto;"
  >
    <!-- En-tête du panneau -->
    <div class="sticky top-0 z-10 flex items-center justify-between border-b border-gray-200 bg-white px-4 py-3 dark:border-gray-700 dark:bg-gray-800">
      <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Notifications</h3>
      <div class="flex items-center gap-2">
        <button
          @click="markAllAsRead()"
          x-show="unreadCount > 0"
          class="text-sm text-brand-600 hover:text-brand-700 dark:text-brand-400"
          style="display: none;"
        >
          Tout marquer comme lu
        </button>
        <button
          @click="panelOpen = false"
          class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
        >
          <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
    </div>

    <!-- Liste des notifications -->
    <div class="divide-y divide-gray-200 dark:divide-gray-700">
      <template x-if="notifications.length === 0">
        <div class="py-8 text-center">
          <p class="text-sm text-gray-500 dark:text-gray-400">Aucune notification</p>
        </div>
      </template>
      <template x-for="notification in notifications" :key="notification.id">
        <div
          @click="openNotification(notification)"
          :class="notification.isRead ? 'bg-white dark:bg-gray-800' : 'bg-blue-50 dark:bg-blue-900/20'"
          class="flex items-start gap-3 p-4 hover:bg-gray-50 dark:hover:bg-gray-700 cursor-pointer transition-colors"
        >
          <div class="flex-1 min-w-0">
            <p class="text-sm font-medium text-gray-900 dark:text-white" x-text="notification.title"></p>
            <p class="text-xs text-gray-500 dark:text-gray-400 mt-1" x-text="notification.message || ''"></p>
            <p class="text-xs text-gray-400 dark:text-gray-500 mt-1" x-text="formatDate(notification.createdAt)"></p>
          </div>
          <button
            @click.stop="deleteNotification(notification.id)"
            class="flex-shrink-0 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
          >
            <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </template>
    </div>

    <!-- Pied du panneau -->
    <div class="sticky bottom-0 border-t border-gray-200 bg-white px-4 py-3 text-center dark:border-gray-700 dark:bg-gray-800">
      <a
        href="{{ path('admin_notifications_list') }}"
        class="text-sm text-brand-600 hover:text-brand-700 dark:text-brand-400"
      >
        Voir toutes les notifications
      </a>
    </div>
  </div>
</div>

<script>
function notificationManager() {
  return {
    panelOpen: false,
    notifications: [],
    unreadCount: 0,
    firebaseDatabase: null,
    firebaseConfig: null,
    userId: {{ app.user.id }},

    async init() {
      await this.loadUnreadCount();
      await this.loadNotifications();
      await this.initFirebase();
    },

    async loadUnreadCount() {
      try {
        const response = await fetch('{{ path('api_notifications_unread_count') }}');
        const data = await response.json();
        this.unreadCount = data.count || 0;
      } catch (error) {
        console.error('Erreur chargement compteur notifications:', error);
      }
    },

    async loadNotifications() {
      try {
        const response = await fetch('{{ path('api_notifications_list') }}?limit=10');
        const data = await response.json();
        if (data.notifications) {
          this.notifications = data.notifications;
        }
      } catch (error) {
        console.error('Erreur chargement notifications:', error);
      }
    },

    async initFirebase() {
      try {
        // Récupérer la configuration Firebase depuis le serveur
        const configResponse = await fetch('{{ path('admin_firebase_config') }}', {
          headers: {
            'Accept': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
          },
          credentials: 'same-origin'
        });
        
        if (!configResponse.ok) {
          console.error('Échec récupération config Firebase');
          return;
        }

        const configData = await configResponse.json();
        
        if (!configData.success || !configData.config) {
          console.error('Configuration Firebase invalide');
          return;
        }

        this.firebaseConfig = configData.config;

        // Initialiser Firebase
        if (typeof firebase !== 'undefined') {
          firebase.initializeApp(this.firebaseConfig);
          this.firebaseDatabase = firebase.database();

          // Écouter les nouvelles notifications
          const notificationsRef = this.firebaseDatabase.ref(`/notifications/user/${this.userId}/notifications`);
          notificationsRef.limitToLast(1).on('child_added', (snapshot) => {
            const notification = snapshot.val();
            this.handleRealtimeNotification(notification);
          });

          // Écouter les mises à jour
          const updatesRef = this.firebaseDatabase.ref(`/notifications/user/${this.userId}/updates`);
          updatesRef.limitToLast(1).on('child_added', (snapshot) => {
            const update = snapshot.val();
            this.handleRealtimeUpdate(update);
          });

          console.log('✅ Connecté à Firebase pour les notifications temps réel');
        } else {
          console.error('Firebase SDK non chargé');
        }
      } catch (error) {
        console.error('Erreur initialisation Firebase:', error);
      }
    },
    
    handleRealtimeUpdate(update) {
      if (update.type === 'all_read') {
        this.notifications.forEach(n => n.isRead = true);
        this.unreadCount = 0;
        this.updateBadge();
      } else if (update.type === 'notification_read') {
        const notification = this.notifications.find(n => n.id === update.id);
        if (notification) {
          notification.isRead = true;
          if (this.unreadCount > 0) this.unreadCount--;
          this.updateBadge();
        }
      } else if (update.type === 'notification_deleted') {
        this.notifications = this.notifications.filter(n => n.id !== update.id);
        this.loadUnreadCount();
      }
    },

    handleRealtimeNotification(data) {
      if (data.type === 'all_read') {
        // Toutes les notifications marquées comme lues
        this.notifications.forEach(n => n.isRead = true);
        this.unreadCount = 0;
        return;
      }

      if (data.type === 'notification_read') {
        // Une notification marquée comme lue
        const notification = this.notifications.find(n => n.id === data.id);
        if (notification) {
          notification.isRead = true;
          if (this.unreadCount > 0) {
            this.unreadCount--;
          }
        }
        return;
      }

      if (data.type === 'notification_deleted') {
        // Une notification supprimée
        this.notifications = this.notifications.filter(n => n.id !== data.id);
        return;
      }

      // Nouvelle notification
      if (data.id) {
        this.notifications.unshift(data);
        if (!data.isRead) {
          this.unreadCount++;
        }
        // Limiter à 10 notifications dans le panneau
        if (this.notifications.length > 10) {
          this.notifications = this.notifications.slice(0, 10);
        }
        // Afficher une notification toast si disponible
        this.showToast(data);
      }
    },

    showToast(notification) {
      // Utiliser le système de toast existant si disponible
      if (window.showToast) {
        window.showToast(notification.title, 'info', {
          onClick: () => {
            if (notification.url) {
              window.location.href = notification.url;
            }
          }
        });
      }
    },

    togglePanel() {
      this.panelOpen = !this.panelOpen;
      if (this.panelOpen) {
        this.loadNotifications();
      }
    },

    async openNotification(notification) {
      // Marquer comme lu si ce n'est pas déjà fait
      if (!notification.isRead) {
        await this.markAsRead(notification.id);
      }
      
      // Rediriger vers l'URL de la notification
      if (notification.url) {
        window.location.href = notification.url;
      }
    },

    async markAsRead(notificationId) {
      try {
        const response = await fetch(`{{ path('api_notifications_mark_read', {id: 'PLACEHOLDER'}) }}`.replace('PLACEHOLDER', notificationId), {
          method: 'POST',
          headers: {
            'X-Requested-With': 'XMLHttpRequest'
          }
        });
        
        if (response.ok) {
          const notification = this.notifications.find(n => n.id === notificationId);
          if (notification && !notification.isRead) {
            notification.isRead = true;
            if (this.unreadCount > 0) {
              this.unreadCount--;
            }
          }
        }
      } catch (error) {
        console.error('Erreur marquage comme lu:', error);
      }
    },

    async markAllAsRead() {
      try {
        const response = await fetch('{{ path('api_notifications_mark_all_read') }}', {
          method: 'POST',
          headers: {
            'X-Requested-With': 'XMLHttpRequest'
          }
        });
        
        if (response.ok) {
          this.notifications.forEach(n => n.isRead = true);
          this.unreadCount = 0;
        }
      } catch (error) {
        console.error('Erreur marquage tout comme lu:', error);
      }
    },

    async deleteNotification(notificationId) {
      try {
        const response = await fetch(`{{ path('api_notifications_delete', {id: 'PLACEHOLDER'}) }}`.replace('PLACEHOLDER', notificationId), {
          method: 'DELETE',
          headers: {
            'X-Requested-With': 'XMLHttpRequest'
          }
        });
        
        if (response.ok) {
          const notification = this.notifications.find(n => n.id === notificationId);
          if (notification && !notification.isRead) {
            if (this.unreadCount > 0) {
              this.unreadCount--;
            }
          }
          this.notifications = this.notifications.filter(n => n.id !== notificationId);
        }
      } catch (error) {
        console.error('Erreur suppression notification:', error);
      }
    },

    formatDate(dateString) {
      if (!dateString) return '';
      
      try {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);
        
        if (diffMins < 1) return 'À l\'instant';
        if (diffMins < 60) return `Il y a ${diffMins} min`;
        if (diffHours < 24) return `Il y a ${diffHours} h`;
        if (diffDays < 7) return `Il y a ${diffDays} j`;
        
        return date.toLocaleDateString('fr-FR', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      } catch (e) {
        return dateString;
      }
    }
  };
}
</script>

